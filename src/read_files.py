# -*- coding: utf-8 -*-
"""
@ Time: {DATE},{TIME}
@ author: LiangHongli
@ Mail: i.hong.li@foxmail.com
读取文件：RTTOV计算的地表发射率、level-to-space透过率、亮温和辐射率等
读取grib2文件，2019-09-20加。
"""
import numpy as np
import h5py
from netCDF4 import Dataset
from my_funcs import rh2q
###################################################################################
######################### read files generated by RTTOV(output files) ###########################
def trans_lv2space(fname,nprof,nch,nlv):
    '''
    Read level-to-space transmittance from the txt file.
    :param fname: directory the file
    :param nprof: the number of profiles
    :param nch: the number of channels
    :param nlv: the number of levels
    :return: reconstructed transmittance with shape (nch,npro,nlv)
    '''
    trans = np.zeros([nlv,nch*nprof]) #[nlevel,nchannel*nprofile]
    with open(fname,'r') as f:
        lines = f.readlines()
        for k,line in enumerate(lines):
            if 'TAU_LAYERS' in line:
                a = k
                break
            else:
                continue
        lines = lines[a:]
        m = 0
        lv = 0
        for line in lines:
            try:
                x = np.array([float(x) for x in line.split()])
                n = len(x)

            except:
                continue
            if n>0:
                trans[lv,m*10:m*10+n] = x
                m += 1
            else:
                lv += 1
                m = 0

    return trans.T.reshape((nprof,nch,nlv))

def bt_clear(fname,nch):
    '''
    读取RTTOV直接计算的晴空亮温
    :param fname: 文件名或路径
    :param nprof: the number of profiles
    :param nch: the number of channels
    :return: bt，数组，晴空亮温
    '''
    with open(fname,'r') as f:
        lines = f.readlines()
    for k,l in enumerate(lines):
        if 'RADIANCE%BT_CLEAR' in l:
            a = k
        elif 'RADIANCE%OVERCAST' in l:
            b = k-1
            break
        else:
            continue

    lines = lines[a:b]
    for k,line in enumerate(lines):
        try:
            xx = np.array([float(x) for x in line.split()])
            if k==1:
                bt = xx
            else:
                bt = np.append(bt,xx)
        except:
            continue

    return bt.reshape(-1,nch)

def rad_clear(fname,npro,nch):
    '''
    Read clear-sky radiances from rad_out files.
    :param fname: directory of the file
    :param npro: the number of profile
    :param nch: the number of channels
    :return: reconstructed radiances, np.array with shape [npro, nch]
    '''
    with open(fname,'r') as f:
        lines = f.readlines()
    for k,l in enumerate(lines):
        if 'RADIANCE%CLEAR' in l:
            a = k
        elif 'RADIANCE%BT_CLEAR' in l:
            b = k-1
            break
        else:
            continue
    lines = lines[a:b]

    radiances = np.zeros((npro*nch,1),dtype=float)
    a = 0
    for line in lines:
        # print(line)
        try:
            xx = [float(x) for x in line.split()]
            # print(xx)
            n = len(xx)
            radiances[a*10:a*10+n,0] = xx
            a += 1
        except:
            continue

    # print(radiances[:100])
    return radiances.reshape((npro,nch))

def trans_srf(fname,nch):
    '''
    读取surface-to-space的透过率
    :param fname: 文件名或路径
    :param nprof: the number of profiles
    :param nch: the number of channels
    :return: trans_surface
    '''
    with open(fname,'r') as f:
        lines = f.readlines()
    for k,l in enumerate(lines):
        if 'TRANSMISSION%TAU_TOTAL' in l:
            a = k
        elif 'TRANSMISSION%TAU_LAYERS' in l:
            b = k-1
            break
        else:
            continue

    lines = lines[a:b]
    for k,line in enumerate(lines):
        try:
            xx = np.array([float(x) for x in line.split()])
            if k==1:
                trans_surface = xx
            else:
                trans_surface = np.append(trans_surface,xx)
        except:
            continue

    return trans_surface.reshape((-1,nch))

def emisi_suf(fname,nch):
    '''
    读取地表发射率
    :param fname: 文件名或路径
    :return: emissivity
    '''
    with open(fname,'r') as f:
        lines = f.readlines()
        for k,line in enumerate(lines):
            try:
                xx = np.array([float(x) for x in line.split()])
                # print(k,xx)
                if k==1:
                    emissivity = xx
                else:
                    emissivity = np.append(emissivity,xx)
            except:
                continue

    return emissivity.reshape((-1,nch))
################################ End! ###############################################
######## Read RTTOV input files: atm variables, ground variables, time and space variables ##############
def temp_suf(fname):
    '''
    从ground的skin.txt中读取地表温度
    :param fname:文件名或路径
    :return: temp_skin
    '''
    with open(fname,'r') as f:
        lines = f.readlines()
        for line in lines:
            if 'k0%t' in line:
                temp_skin = float(line.split('=')[1])
            else:
                continue

    return temp_skin

def read_profile(propath):
    '''
    Read profile variables from propath directory
    :param propath: directory, string or path
    :return: profile, array
    '''
    atmdir = propath / 'atm'
    # p = np.loadtxt(atmdir / 'p.txt')
    t = np.loadtxt(atmdir / 't.txt')
    q = np.loadtxt(atmdir / 'q.txt')
    # cc = np.loadtxt(atmdir/'cc.txt')
    groundir = propath / 'ground'
    with open(groundir / 's2m.txt') as f:
        lines = f.readlines()[1:]
        for ln in lines:
            if 't' in ln:
                t2m = float(ln.split('=')[-1])
            elif 'p' in ln:
                p2m = float(ln.split('=')[-1])
            elif 'q' in ln:
                q2m = float(ln.split('=')[-1])
            elif 'u' in ln:
                u2m = float(ln.split('=')[-1])
            elif 'v' in ln:
                v2m = float(ln.split('=')[-1])

    with open(groundir / 'skin.txt') as f:
        lines = f.readlines()[1:4]
        for ln in lines:
            if 'surftype' in ln:
                srftype = float(ln.split('=')[-1])
            elif 'k0%t' in ln:
                st = float(ln.split('=')[-1])

    with open(propath / 'angles.txt') as f:
        lines = f.readlines()[1:]
        for ln in lines:
            if 'zenangle' in ln:
                zen = float(ln.split('=')[-1])
            elif 'latitude' in ln:
                lat = float(ln.split('=')[-1])
            elif 'longitude' in ln:
                lon = float(ln.split('=')[-1])
            elif 'elevation' in ln:
                ele = float(ln.split('=')[-1])

    month = np.loadtxt(propath / 'datetime.txt')[1]
    if (atmdir/'o3.txt').exists():
        o3 = np.loadtxt(atmdir / 'o3.txt')
        # profile = np.hstack((t, q, o3, p2m, t2m, u2m, v2m, st, srftype, lon, lat, ele,zen,month))
        profile = np.hstack((t, q, o3, p2m, t2m, u2m, v2m, st, srftype, lon, lat, ele, month))
    else:
        # profile = np.hstack((t, q, p2m, t2m, u2m, v2m, st, srftype, lon, lat, ele, zen, month))
        profile = np.hstack((t, q, p2m, t2m, u2m, v2m, st, srftype, lon, lat, ele, month))
    return profile.reshape(1,-1)

################################ End! ###############################################
############## read files of IRAS observation ####################################
def read_IRAS_3c(fname):
    with h5py.File(fname,'r') as f:
        bt = f['Data/IRAS_TB'][:]
        lats = f['Geolocation/Latitude'][:]
        lons = f['Geolocation/Longitude'][:]
        senzenith = f['Geolocation/SensorZenith'][:]*0.01 # unit=degrees
        solzenith = f['Geolocation/SolarZenith'][:]*0.01
        azangle = f['Geolocation/SensorAzimuth'][:]*0.01
        sunazangle = f['Geolocation/SolarAzimuth'][:]*0.01
        lsmask = f['Geolocation/LandSeaMask'][:] # 1=land, 2=inland water, 3=sea, 5=border
        dem = f['Geolocation/DEM'][:]*0.01 # unit=km

    bt[bt<150] = np.nan
    bt[bt>350] = np.nan
    # lon_lats = np.concatenate((lons.ravel(),lats.ravel()),axis=1)
    # zenith = np.concatenate((senzenith.ravel(),solzenith.ravel()),axis=1)
    return bt, lons, lats, senzenith,solzenith,azangle,sunazangle,lsmask,dem

def read_IRAS_3a(fname):
    with h5py.File(fname,'r') as f:
        bt = f['FY3A_IRAS_TB'][:]
        lats = f['Latitude'][:]
        lons = f['Longitude'][:]
        senzenith = f['SensorZenith'][:]*0.01 # unit=degrees
        solzenith = f['SolarZenith'][:]*0.01
        azangle = f['SensorAzimuth'][:]*0.01
        sunazangle = f['SolarAzimuth'][:]*0.01
        lsmask = f['LandSeaMask'][:] # 1=land, 2=inland water, 3=sea, 5=border
        dem = f['Height'][:]*0.01*0.001 # unit=km

    # bt[bt<150] = -999
    # bt[bt>350] = -999
    # lon_lats = np.concatenate((lons.ravel(),lats.ravel()),axis=1)
    # zenith = np.concatenate((senzenith.ravel(),solzenith.ravel()),axis=1)
    return bt, lons, lats, senzenith,solzenith,azangle,sunazangle,lsmask,dem

def read_cld(fname):
    with h5py.File(fname,'r') as f:
        cld_mask = f['CloudMask'][:]

    return cld_mask
######################################################################################
############## read nc files converting from GRAPES grib2 files ########################
variable_list_forecast = {
    'HGT_P0_L100_GLL0',
    'TMP_P0_L100_GLL0',
    'SPFH_P0_L100_GLL0',
    'UGRD_P0_L103_GLL0',
    'VGRD_P0_L103_GLL0',
    'TMP_P0_L103_GLL0',
    'TMP_P0_L1_GLL0',
    'PRES_P0_L1_GLL0',
    'SPFH_P0_L103_GLL0',
    'TCDC_P0_L2_GLL0',
    'HGT_P0_L1_GLL0',
    'lv_ISBL0',
    'lv_ISBL2',
    'lat_0',
    'lon_0'
}
variable_list_analysis = {
    'lv_ISBL0',
    'lv_ISBL4',
    'lat_0',
    'lon_0',
    'PRES_P0_L1_GLL0',
    'SPFH_P0_L103_GLL0',
    'RH_P0_L100_GLL0',
    'TMP_P0_L103_GLL0',
    'TMP_P0_L100_GLL0',
    'TMP_P0_L1_GLL0',
    'UGRD_P0_L103_GLL0',
    'VGRD_P0_L103_GLL0'
}
def read_nc_forecast(fname):
    with Dataset(fname,'r') as f:
        lv30 = f.variables['lv_ISBL2'][:]/100 #unit=hPa
        lv40 = f.variables['lv_ISBL0'][:]/100 #unit=hPa

        hgt_surf = f.variables['HGT_P0_L1_GLL0'][:] #unit=gpm
        pres_surf = f.variables['PRES_P0_L1_GLL0'][:]/100 #unit=hPa
        tmp_surf = f.variables['TMP_P0_L1_GLL0'][:] #unit=K

        tmp_2m = f.variables['TMP_P0_L103_GLL0'][:] #unit=K
        q_2m = f.variables['SPFH_P0_L103_GLL0'][:] #unit=kg/kg
        u_2m = f.variables['UGRD_P0_L103_GLL0'][:] #unit=m/s
        v_2m = f.variables['VGRD_P0_L103_GLL0'][:]

        hgt_l100 = f.variables['HGT_P0_L100_GLL0'][:] #unit=gpm
        tmp_l100 = f.variables['TMP_P0_L100_GLL0'][:] #unit=K
        q_l100 = f.variables['SPFH_P0_L100_GLL0'][:] #unit=kg/kg

    return lv30,lv40,hgt_surf,pres_surf,tmp_surf,tmp_2m,q_2m,u_2m,v_2m,hgt_l100,tmp_l100,q_l100

from scipy.interpolate import RegularGridInterpolator
def read_nc_analysis(fname):
    with Dataset(fname,'r') as f:
        lv21 = f.variables['lv_ISBL4'][:]/100 #unit=hPa
        lv26 = f.variables['lv_ISBL0'][:]/100 #unit=hPa

        pres_surf = f.variables['PRES_P0_L1_GLL0'][:]/100 #unit=hPa
        tmp_surf = f.variables['TMP_P0_L1_GLL0'][:] #unit=K

        tmp_2m = f.variables['TMP_P0_L103_GLL0'][:] #unit=K
        q_2m = f.variables['SPFH_P0_L103_GLL0'][:] #unit=kg/kg
        u_2m = f.variables['UGRD_P0_L103_GLL0'][:] #unit=m/s
        v_2m = f.variables['VGRD_P0_L103_GLL0'][:]

        tmp_l100 = f.variables['TMP_P0_L100_GLL0'][:] #unit=K,shape=(26,361,720)
        rh_l100 = f.variables['RH_P0_L100_GLL0'][:]*0.01 #unit=1,shape=(21,361,720)
        lats = f.variables['lat_0'][:]
        lons = f.variables['lon_0'][:]

    return lv21,lv26,pres_surf,tmp_surf,tmp_2m,q_2m,u_2m,v_2m,tmp_l100,rh_l100,lats,lons

def read_era5_pressure_level(fname,index=None):
    with Dataset(fname,'r') as f:
        if index!=None:
            tmp = f.variables['t'][index]
            q = f.variables['q'][index]
            o3 = f.variables['o3'][index]
            cc = f.variables['cc'][index]
        else:
            tmp = f.variables['t'][:]
            q = f.variables['q'][:]
            o3 = f.variables['o3'][:]
            cc = f.variables['cc'][:]
            
        level = f.variables['level'][:]
        lats = f.variables['latitude'][:]
        lons = f.variables['longitude'][:]

    return tmp,q,o3,cc,level,lons,lats

def read_era5_single_level(fname):
    with Dataset(fname,'r') as f:
        lats = f.variables['latitude'][:]
        lons = f.variables['longitude'][:]
        
        # scale = f.variables['t2m'].scale_factor
        # offset = f.variables['t2m'].add_offset
        t2m = f.variables['t2m'][:]#*scale+offset # unit=K
        # scale = f.variables['u10'].scale_factor
        # offset = f.variables['u10'].add_offset
        u2m = f.variables['u10'][:]#*scale+offset # unit=m/s
        # scale = f.variables['v10'].scale_factor
        # offset = f.variables['v10'].add_offset
        v2m = f.variables['v10'][:]#*scale+offset # unit=m/s
        
        # scale = f.variables['skt'].scale_factor
        # offset = f.variables['skt'].add_offset
        t_skin = f.variables['skt'][:]#*scale+offset # unit=K
        # scale = f.variables['sp'].scale_factor
        # offset = f.variables['sp'].add_offset
        p_skin = f.variables['sp'][:]*0.01#*scale+offset # unit=mb(hPa)
        
    return t2m,u2m,v2m,t_skin,p_skin,lons,lats
def read_make_era5(fname):
    with h5py.File(fname,'r') as f:
        t = f['t'][:]
        q = f['q'][:]
        o3 = f['o3'][:]
        level = f['level'][:]
        
    return t,q,o3,level
    
def read_era4_model_level(fname,index=None):
    with Dataset(fname,'r') as f:
        if index!=None:
            t = f.variables['t'][index]
            q = f.variables['q'][index]
            o3 = f.variables['o3'][index]
            cc = f.variables['cc'][index]
        else:
            t = f.variables['t'][:]
            q = f.variables['q'][:]
            o3 = f.variables['o3'][:]
            cc = f.variables['cc'][:]
        lons = f.variables['longitude'][:]
        lats = f.variables['latitude'][:]
        
    return t,q,o3,cc,lons,lats

def read_era4_srf(fname):
    with Dataset(fname,'r') as f:
        lons = f.variables['longitude'][:]
        lats = f.variables['latitude'][:]
        t2m = f.variables['t2m'][:]
        d2m = f.variables['d2m'][:]
        u2m = f.variables['u10'][:]
        v2m = f.variables['v10'][:]
        p_skin = f.variables['sp'][:]
        t_skin = f.variables['skt'][:]
        
    return t2m,d2m,u2m,v2m,t_skin,p_skin,lons,lats

def read_nc_llc(fname):
    with Dataset(fname,'r') as f:
        lats = f.variables['lat_0'][:]
        lons = f.variables['lon_0'][:]
        cloud = f.variables['TCDC_P0_L2_GLL0'][:] #unit=%

    return lats,lons,cloud
